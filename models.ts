import {
  path,
  rflSQLa as SQLa,
  rflSQLaTypical as SQLaTyp,
  rflSqlDiagram as sqlD,
  rflSqlOsQuery as osQ,
} from "./deps.ts";

/**
 * All our table names should be strongly typed and consistent. Generics are
 * used so that they are passed into Axiom, SQLa domain, etc. properly typed.
 * @param name the name of the table
 * @returns the transformed table name (e.g. in case prefixes should be added)
 */
export function tableName<Name extends string, Qualified extends string = Name>(
  name: Name,
): Qualified {
  return name as unknown as Qualified;
}

export enum ExecutionContext {
  DEVELOPMENT,
  TEST,
  PRODUCTION,
}

export enum AssetRiskType {
  TYPE1 = "asset risk type 1",
  TYPE2 = "asset risk type 2",
}

export function enumerations<Context extends SQLa.SqlEmitContext>(
  ddlOptions?: SQLa.SqlTextSupplierOptions<Context> & {
    readonly sqlNS?: SQLa.SqlNamespaceSupplier;
  },
) {
  const lg = SQLaTyp.typicalLookupsGovn(ddlOptions);
  const execCtx = lg.enumTable(
    tableName("execution_context"),
    ExecutionContext,
  );
  const assetRiskType = lg.enumTextTable(
    tableName("asset_risk_type"),
    AssetRiskType,
  );

  // deno-fmt-ignore
  const DDL = SQLa.SQL<Context>(ddlOptions)`
      ${execCtx}

      ${assetRiskType}

      ${execCtx.seedDML}

      ${assetRiskType.seedDML}`;

  return {
    execCtx,
    assetRiskType,
    DDL,
    exposeATC: [execCtx, assetRiskType],
  };
}

export function entities<Context extends SQLa.SqlEmitContext>(
  ddlOptions?: SQLa.SqlTextSupplierOptions<Context> & {
    readonly sqlNS?: SQLa.SqlNamespaceSupplier;
  },
) {
  const mg = SQLaTyp.typicalModelsGovn(ddlOptions);
  const enums = enumerations(ddlOptions);

  const graph = mg.table(tableName("graph"), {
    graph_id: mg.primaryKey(),
    name: SQLa.text(),
    ...mg.housekeeping(),
  });

  const boundaryId = mg.primaryKey();
  const boundary = mg.table(tableName("boundary"), {
    boundary_id: boundaryId,
    parent_boundary_id: SQLa.selfRefNullableForeignKey(boundaryId),
    name: SQLa.text(),
    graph_id: graph.foreignKeyRef.graph_id(),
    ...mg.housekeeping(),
  });

  const host = mg.table(tableName("host"), {
    host_id: mg.primaryKey(),
    host_name: SQLa.unique(SQLa.text()),
    ...mg.housekeeping(),
  });

  const hostBoundary = mg.table(tableName("host_boundary"), {
    host_boundary_id: mg.primaryKey(),
    host_id: host.foreignKeyRef.host_id(),
    boundary_id: boundary.foreignKeyRef.boundary_id(),
    ...mg.housekeeping(),
  });

  const raciMatrix = mg.table(tableName("raci_matrix"), {
    raci_matrix_id: mg.primaryKey(),
    asset: SQLa.text(),
    responsible: SQLa.text(),
    accountable: SQLa.text(),
    consulted: SQLa.text(),
    informed: SQLa.text(),
    ...mg.housekeeping(),
  });

  const assetRisk = mg.table(tableName("asset_risk"), {
    asset_risk_id: mg.primaryKey(),
    asset_risk_type_id: enums.assetRiskType.foreignKeyRef.code(),
    asset: SQLa.text(),
    threat_event: SQLa.text(),
    relevance: SQLa.text(),
    likelihood: SQLa.text(),
    impact: SQLa.text(),
    ...mg.housekeeping(),
  });

  // deno-fmt-ignore
  const DDL = SQLa.SQL<Context>(ddlOptions)`
      ${host}

      ${graph}

      ${boundary}

      ${hostBoundary}

      ${raciMatrix}

      ${assetRisk}`;

  return {
    host,
    graph,
    boundary,
    hostBoundary,
    raciMatrix,
    assetRisk,
    DDL,
    exposeATC: [host, graph, boundary, hostBoundary, raciMatrix],
  };
}

export function models<Context extends SQLa.SqlEmitContext>(
  ddlOptions?: SQLa.SqlTextSupplierOptions<Context> & {
    readonly sqlNS?: SQLa.SqlNamespaceSupplier;
  },
) {
  const enums = enumerations(ddlOptions);
  const ents = entities(ddlOptions);

  // deno-fmt-ignore
  const DDL = SQLa.SQL<Context>(ddlOptions)`
      -- Generated by ${path.basename(import.meta.url)}. DO NOT EDIT.

      PRAGMA foreign_keys = ON;

      ${SQLa.typicalSqlTextLintSummary}

      -- enumeration tables
      ${enums.DDL}

      -- content tables
      ${ents.DDL}

      ${SQLa.typicalSqlTmplEngineLintSummary}`;

  const atcCS = osQ.osQueryATCConfigSupplier(
    [...enums.exposeATC, ...ents.exposeATC].map((t) => ({
      tableName: t.tableName,
      columns: t.domains.map((d) => ({ columnName: d.identity })),
    })),
  );

  const osQueryATCConfig = (
    sqliteDbPath: string,
    _ctx: Context,
    osQueryTableName: (tableName: string) => string = (tableName) =>
      `opsfolio_${tableName}`,
  ) => {
    return atcCS((tableName, atcPartial) => {
      return {
        osQueryTableName: osQueryTableName(tableName),
        atcRec: { ...atcPartial, path: sqliteDbPath },
      };
    });
  };

  return {
    enumerations: enums,
    entities: ents,
    DDL,
    osQueryATCConfig,
    osQueryATCConfigJsonText: (
      sqliteDbPath: string,
      ctx: Context,
      osQueryTableName?: (tableName: string) => string,
    ) => {
      return JSON.stringify(
        osQueryATCConfig(sqliteDbPath, ctx, osQueryTableName),
      );
    },
    plantUmlIE: (ctx: Context) =>
      sqlD.plantUmlIE(ctx, function* () {
        for (const e of Object.values(enums)) {
          if (SQLaTyp.isEnumTableDefn(e)) {
            yield e;
          }
        }
        for (const e of Object.values(ents)) {
          if (SQLa.isTableDefinition(e)) {
            yield e;
          }
        }
      }, sqlD.typicalPlantUmlIeOptions()),
  };
}

if (import.meta.main) {
  // if we're being called as a CLI, just emit the DDL SQL:
  //    deno run -A models.ts > opsfolio.auto.sql
  //    deno run -A models.ts | sqlite3 opsfolio.sqlite.db
  const m = models();
  console.log(m.DDL.SQL(SQLa.typicalSqlEmitContext()));
}
